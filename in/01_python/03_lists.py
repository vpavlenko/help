{% section "Списки: list" %}

{% subsection "Несортированная информация" %}
Основной структурой данных для хранения объектов с поддержкой индексации являются списки.
Список &mdash; это расширяемый набор ссылок на объекты в памяти. Вообще, в Питоне нет понятия &laquo;переменная&raquo;,
есть только объекты и имена, хранящие ссылки на объекты.

{% program "python" %}
>>> a = [1, 5.2, 'abcd']
>>> len(a)
3
>>> a[0]
1
>>> a[-1]
'abcd'
{% endprogram %}

Несмотря на название, списки реализованы вовсе не на основе односвязных или двусвязных списков.
Внутри списки представляют собой расширяющийся массив (такой же, как контейнер std::vector в языке <nobr>С++</nobr>).
Поэтому списки поддерживают методы для добавления элементов в конец за <nobr>O(1)</nobr>, а также вставки и добавления
элементов в произвольное место за <nobr>O(n)</nobr>.

{% program "python" %}
>>> a = [1, 5.2, 'abcd']
>>> a.append('def')
>>> a
[1, 5.2, 'abcd', 'def']
>>> a.insert(2, 'new_element')
>>> a
[1, 5.2, 'new_element', 'abcd', 'def']
>>> a.pop(-3)
'new_element'
>>> a
[1, 5.2, 'abcd', 'def']
>>> a.remove('abcd')
>>> a
[1, 5.2, 'def']
>>> a.pop()  # метод pop() без аргументов удаляет и возвращает последний элемент списка
'def'
>>> a
[1, 5.2]
{% endprogram %}

В Питоне многие методы работают над семейством схожих объектов. Например, строки и списки в Питоне &mdash;
это последовательности. У последовательностей можно узнавать длину методом len(), последовательности
можно складывать знаком + (конкатенация) и умножать на число (конкатенация, повторенная k раз). Также
можно выбирать куски последовательности с помощью механизма срезов.

{% program "python" %}
>>> [1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
>>> [1, 2, 3] * 4
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> a = [0] * 10  # создание пустого одномерного массива
>>> a
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
>>> a = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
>>> a[1:4]   # срез с первого по четвертый элемент, исключая правую границу
[11, 12, 13]
>>> a[2:]    # срез со второго элемента до конца
[12, 13, 14, 15, 16, 17, 18, 19]
>>> a[:5]    # срез от начала до пятого элемента исключительно
[10, 11, 12, 13, 14]
>>> a[:-3]   # индексы в срезах могут быть отрицательными
[10, 11, 12, 13, 14, 15, 16]
>>> a[2:8:2] # третий необязательный параметр: шаг среза
[12, 14, 16]
>>> a[::2]
[10, 12, 14, 16, 18]
>>> a[::-1]  # простой способ развернуть список
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10]
>>> s = 'abcde'
>>> s[::-1]  # всё это работает и над строками
'edcba'
{% endprogram %}

Как уже говорилось, строки являются неизменяемым типом данных. Если нам нужно часто работать с символами строки,
то можно поступить так: сначала преобразовать строку в список, потом провести необходимые изменения, а потом 
обратно собрать строку из списка строк.

{% program "python" %}
>>> s = 'abcde'
>>> a = list(s)
>>> a
['a', 'b', 'c', 'd', 'e']
>>> a[2] = 'k'
>>> a.append('f')
>>> a
['a', 'b', 'k', 'd', 'e', 'f']
>>> ''.join(a)
'abkdef'
>>> ', '.join(a)
'a, b, k, d, e, f'
{% endprogram %}

Для создания списков на основе других последовательностей существует механизм генераторов (list comprehensions).
Синтаксис наиболее частого варианта использования: 
<br><code>[выражение <b>for</b> переменная <b>in</b> последовательность <b>if</b> условие]</code>
<br>Для получения последовательности подряд идущих чисел можно использовать функцию range(). 
range(last) порождает возрастающую последовательность от 0 до last - 1. 
Функция range(first, last[, step]) порождает последовательность от first до last - 1 с шагом step.

{% program "python" %}
[]

{% endprogram %}

Двумерные массивы
{% endsubsection %}



{% subsection "collections.deque" %}
{% endsubsection %}


{% endsection %}
